// Generated by CoffeeScript 2.3.2
(function() {
  var Point, SelectablePoint, Track, TrackSegment;

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  Point = (function() {
    class Point {
      constructor(app1, i3, j3) {
        this.app = app1;
        this.i = i3;
        this.j = j3;
      }

    };

    Point.property('index', {
      get: function() {
        return [this.i, this.j];
      },
      set: function(index) {
        return [this.i, this.j] = index;
      }
    });

    Point.property('x', {
      get: function() {
        return this.app.style.tox(this.j);
      }
    });

    Point.property('y', {
      get: function() {
        return this.app.style.toy(this.i);
      }
    });

    Point.property('pos', {
      get: function() {
        return [this.x, this.y];
      }
    });

    return Point;

  }).call(this);

  SelectablePoint = (function() {
    class SelectablePoint extends Point {
      constructor(app, i, j) {
        super(app, i, j);
        this._selected = false;
      }

      set_event_handlers(element) {
        element.hover(((e) => {
          return this.onhover(e);
        }), ((e) => {
          return this.unhover(e);
        }));
        return element.click((e) => {
          return this.onclick(e);
        });
      }

      select() {
        this.app.metro.unselect_all();
        return this.selected = true;
      }

      unselect() {
        return this.selected = false;
      }

      toggle_select() {
        if (this.selected) {
          return this.unselect();
        } else {
          return this.select();
        }
      }

      draw() {}

      update_drawing() {}

      onhover(e) {}

      unhover(e) {}

      onclick(e) {}

    };

    SelectablePoint.property('selected', {
      get: function() {
        return this._selected;
      },
      set: function(s) {
        if (this.selected && !s) {
          this.app.inspector.unset();
        }
        if (!this.selected && s) {
          this.app.inspector.set(this);
        }
        this._selected = s;
        return this.update_drawing();
      }
    });

    return SelectablePoint;

  }).call(this);

  TrackSegment = class TrackSegment extends Point {
    constructor(app, track, i1, j1, i21, j21) {
      super(app, i1, j1);
      this.track = track;
      this.i2 = i21;
      this.j2 = j21;
      this.draw();
      this.track.group.add(this.path);
    }

    draw() {
      this.path = this.app.metro.svg.path(this.get_path_str());
      return this.path.attr({
        fill: 'none',
        stroke: this.track.color,
        strokeWidth: 8
      });
    }

    get_path_str() {
      var d, path, r, x1, x2, y1, y2;
      r = 0.95 * this.app.style.node.radius;
      d = this.app.style.geometry.scale[1] * this.app.style.track.smooth_factor;
      x1 = this.app.style.tox(this.j);
      y1 = this.app.style.toy(this.i) + r;
      x2 = this.app.style.tox(this.j2);
      y2 = this.app.style.toy(this.i2) - r;
      return path = `M ${x1},${y1} C ${x1},${y1 + d} ${x2},${y2 - d} ${x2},${y2}`;
    }

  };

  Track = (function() {
    class Track extends Point {
      constructor(app, start, end, djs, color_index) {
        super(app, start.i, start.j);
        this.end = end;
        this.color_index = color_index;
        this.start = start;
        this.group = this.app.metro.svg.group();
        this.segments = this.create_segments(djs);
        this.update_group();
      }

      update_group() {
        if (this.start.state === 'done' && this.end.is_active) {
          return this.app.metro.groups.active_tracks.add(this.group);
        } else {
          return this.app.metro.groups.inactive_tracks.add(this.group);
        }
      }

      create_segments(djs) {
        var i1, i2, j1, j2, k, l, ref, segments;
        segments = [];
        i1 = this.start.i;
        j1 = this.start.j;
        for (k = l = 0, ref = djs.length; (0 <= ref ? l < ref : l > ref); k = 0 <= ref ? ++l : --l) {
          i2 = i1 + 1;
          j2 = j1 + djs[k];
          segments.push(new TrackSegment(this.app, this, i1, j1, i2, j2));
          i1 = i2;
          j1 = j2;
        }
        i2 = this.end.i;
        j2 = this.end.j;
        segments.push(new TrackSegment(this.app, this, i1, j1, i2, j2));
        return segments;
      }

    };

    Track.property('color', {
      get: function() {
        return this.app.style.palette[this.color_index];
      }
    });

    return Track;

  }).call(this);

  define(function() {
    var Node;
    return Node = (function() {
      class Node extends SelectablePoint {
        constructor(app, id1, {i, j, title, state, color_index, description, conditions} = {}) {
          super(app, i, j);
          this.id = id1;
          this.title = title;
          this.color_index = color_index;
          this.description = description;
          this.conditions = conditions;
          this.draw();
          this.set_event_handlers(this.group);
          this.update_drawing();
          this.state = state;
          this.is_hover = false;
        }

        update(upt) {
          var c, id, ref, u;
          if (upt.title !== void 0) {
            this.title = upt.title;
          }
          if (upt.description !== void 0) {
            this.description = upt.description;
          }
          if (upt.conditions !== void 0) {
            ref = upt.conditions;
            for (id in ref) {
              u = ref[id];
              c = this.conditions[id];
              if (u.title !== void 0) {
                c.title = u.title;
              }
              if (u.description !== void 0) {
                c.description = u.description;
              }
              if (u.state !== void 0) {
                this.set_conditions_states(id, u.state);
              }
            }
          }
          if (upt.state !== void 0) {
            return this.state = upt.state;
          }
        }

        update_tracks() {
          var l, len, ref, results, t;
          ref = this.tracks;
          results = [];
          for (l = 0, len = ref.length; l < len; l++) {
            t = ref[l];
            results.push(t.update_group());
          }
          return results;
        }

        set_tracks(tracks) {
          var t;
          return this.tracks = (function() {
            var l, len, results;
            results = [];
            for (l = 0, len = tracks.length; l < len; l++) {
              t = tracks[l];
              results.push(new Track(this.app, this, this.app.metro.grid[t.child], t.djs, t.color_index));
            }
            return results;
          }).call(this);
        }

        set_conditions_states(id, state) {
          var comp_new, comp_old, r0, rescale;
          comp_old = this.completion;
          if (state !== this.conditions[id].state) {
            r0 = this.app.style.node.radius;
            rescale = (s) => {
              var m;
              m = new Snap.Matrix();
              m.scale(s, s, this.x, this.y);
              return this.group.transform(m);
            };
            Snap.animate(1, 1.2, rescale, 200, mina.easeout);
            Snap.animate(1.2, 1, rescale, 400, mina.easeout);
          }
          this.conditions[id].state = state;
          comp_new = this.completion;
          return Snap.animate(comp_old * 359.99, comp_new * 359.99, (angle) => {
            return this.completion_circle.attr({
              d: this.create_completion_circle(this.x, this.y, this.app.style.node.radius, this.app.style.node.completion.angle_offset, angle)
            });
          }, this.app.style.node.completion.duration, mina.easeout);
        }

        draw() {
          var path;
          this.circle = this.app.metro.svg.circle(this.x, this.y, this.app.style.node.radius);
          this.circle.attr({
            strokeWidth: this.app.style.node.stroke_width
          });
          path = this.create_completion_circle(this.x, this.y, this.app.style.node.radius, this.app.style.node.completion.angle_offset, this.completion * 359.99);
          this.completion_circle = this.app.metro.svg.path(path);
          this.completion_circle.attr({
            opacity: this.app.style.node.completion.opacity
          });
          this.group = this.app.metro.svg.group();
          this.group.add(this.circle);
          this.group.add(this.completion_circle);
          return this.group.node.style.cursor = 'pointer';
        }

        update_drawing() {
          var color, highlight, s;
          color = tinycolor(this.color);
          color = '#' + (this.is_hover ? color.lighten() : color).toHex();
          s = this.app.style.node.highlight;
          highlight = '';
          if (this.selected) {
            highlight = this.app.metro.svg.filter(Snap.filter.shadow(s.x, s.y, s.blur, this.color, s.opacity));
          }
          this.circle.attr({
            fill: this.app.style.node.fill,
            stroke: color,
            filter: highlight
          });
          return this.completion_circle.attr({
            fill: color
          });
        }

        create_completion_circle(cx, cy, r, start, angle) {
          var is_large_arc, p_end, p_start, path;
          p_start = {
            x: cx + r * Math.cos(Math.PI * start / 180),
            y: cy + r * Math.sin(Math.PI * start / 180)
          };
          p_end = {
            x: cx + r * Math.cos(Math.PI * (start + angle) / 180),
            y: cy + r * Math.sin(Math.PI * (start + angle) / 180)
          };
          is_large_arc = angle > 180 ? 1 : 0;
          return path = `M${cx},${cy} L${p_start.x},${p_start.y} A${r},${r} 0 ${is_large_arc},1 ${p_end.x},${p_end.y} L${cx},${cy} Z`;
        }

        onhover(e) {
          this.is_hover = true;
          return this.update_drawing();
        }

        unhover(e) {
          this.is_hover = false;
          return this.update_drawing();
        }

        onclick(e) {
          return this.toggle_select();
        }

      };

      Node.property('color', {
        get: function() {
          return this.app.style.palette[this.color_index];
        }
      });

      Node.property('state', {
        get: function() {
          return this._state;
        },
        set: function(s) {
          this._state = s;
          if (this.is_active) {
            return this.app.metro.groups.active_nodes.add(this.group);
          } else {
            return this.app.metro.groups.inactive_nodes.add(this.group);
          }
        }
      });

      Node.property('is_active', {
        get: function() {
          return this.state === "active" || this.state === "done";
        }
      });

      Node.property('completion', {
        get: function() {
          var _, c, completion, done, total;
          done = (function() {
            var ref, results;
            ref = this.conditions;
            results = [];
            for (_ in ref) {
              c = ref[_];
              if (c.state === 'done') {
                results.push(c);
              }
            }
            return results;
          }).call(this);
          total = (function() {
            var ref, results;
            ref = this.conditions;
            results = [];
            for (_ in ref) {
              c = ref[_];
              results.push(c);
            }
            return results;
          }).call(this);
          return completion = done.length / total.length;
        }
      });

      return Node;

    }).call(this);
  });

}).call(this);
