// Generated by CoffeeScript 1.9.3
(function() {
  var Point, SelectablePoint, Track, TrackSegment,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  Point = (function() {
    function Point(app1, i3, j3) {
      this.app = app1;
      this.i = i3;
      this.j = j3;
    }

    Point.property('index', {
      get: function() {
        return [this.i, this.j];
      },
      set: function(index) {
        return this.i = index[0], this.j = index[1], index;
      }
    });

    Point.property('x', {
      get: function() {
        return this.app.style.tox(this.j);
      }
    });

    Point.property('y', {
      get: function() {
        return this.app.style.toy(this.i);
      }
    });

    Point.property('pos', {
      get: function() {
        return [this.x, this.y];
      }
    });

    return Point;

  })();

  SelectablePoint = (function(superClass) {
    extend(SelectablePoint, superClass);

    function SelectablePoint(app, i, j) {
      SelectablePoint.__super__.constructor.call(this, app, i, j);
      this._selected = false;
    }

    SelectablePoint.prototype.set_event_handlers = function(element) {
      element.hover(((function(_this) {
        return function(e) {
          return _this.onhover(e);
        };
      })(this)), ((function(_this) {
        return function(e) {
          return _this.unhover(e);
        };
      })(this)));
      return element.click((function(_this) {
        return function(e) {
          return _this.onclick(e);
        };
      })(this));
    };

    SelectablePoint.property('selected', {
      get: function() {
        return this._selected;
      },
      set: function(s) {
        if (this.selected && !s) {
          this.app.inspector.unset();
        }
        if (!this.selected && s) {
          this.app.inspector.set(this);
        }
        this._selected = s;
        return this.update_drawing();
      }
    });

    SelectablePoint.prototype.select = function() {
      this.app.metro.unselect_all();
      return this.selected = true;
    };

    SelectablePoint.prototype.unselect = function() {
      return this.selected = false;
    };

    SelectablePoint.prototype.toggle_select = function() {
      if (this.selected) {
        return this.unselect();
      } else {
        return this.select();
      }
    };

    SelectablePoint.prototype.draw = function() {};

    SelectablePoint.prototype.update_drawing = function() {};

    SelectablePoint.prototype.onhover = function(e) {};

    SelectablePoint.prototype.unhover = function(e) {};

    SelectablePoint.prototype.onclick = function(e) {};

    return SelectablePoint;

  })(Point);

  TrackSegment = (function(superClass) {
    extend(TrackSegment, superClass);

    function TrackSegment(app, track, i1, j1, i21, j21) {
      this.track = track;
      this.i2 = i21;
      this.j2 = j21;
      TrackSegment.__super__.constructor.call(this, app, i1, j1);
      this.draw();
      this.track.group.add(this.path);
    }

    TrackSegment.prototype.draw = function() {
      this.path = this.app.metro.svg.path(this.get_path_str());
      return this.path.attr({
        fill: 'none',
        stroke: this.track.color,
        strokeWidth: 8
      });
    };

    TrackSegment.prototype.get_path_str = function() {
      var d, path, r, x1, x2, y1, y2;
      r = 0.95 * this.app.style.node.radius;
      d = this.app.style.geometry.scale[1] * this.app.style.track.smooth_factor;
      x1 = this.app.style.tox(this.j);
      y1 = this.app.style.toy(this.i) + r;
      x2 = this.app.style.tox(this.j2);
      y2 = this.app.style.toy(this.i2) - r;
      return path = "M " + x1 + "," + y1 + " C " + x1 + "," + (y1 + d) + " " + x2 + "," + (y2 - d) + " " + x2 + "," + y2;
    };

    return TrackSegment;

  })(Point);

  Track = (function(superClass) {
    extend(Track, superClass);

    function Track(app, start, end, djs, color_index) {
      this.end = end;
      this.color_index = color_index;
      Track.__super__.constructor.call(this, app, start.i, start.j);
      this.start = start;
      this.group = this.app.metro.svg.group();
      this.segments = this.create_segments(djs);
      this.update_group();
    }

    Track.prototype.update_group = function() {
      if (this.start.state === 'done' && this.end.is_active) {
        return this.app.metro.groups.active_tracks.add(this.group);
      } else {
        return this.app.metro.groups.inactive_tracks.add(this.group);
      }
    };

    Track.prototype.create_segments = function(djs) {
      var i1, i2, j1, j2, k, l, ref, segments;
      segments = [];
      i1 = this.start.i;
      j1 = this.start.j;
      for (k = l = 0, ref = djs.length; 0 <= ref ? l < ref : l > ref; k = 0 <= ref ? ++l : --l) {
        i2 = i1 + 1;
        j2 = j1 + djs[k];
        segments.push(new TrackSegment(this.app, this, i1, j1, i2, j2));
        i1 = i2;
        j1 = j2;
      }
      i2 = this.end.i;
      j2 = this.end.j;
      segments.push(new TrackSegment(this.app, this, i1, j1, i2, j2));
      return segments;
    };

    Track.property('color', {
      get: function() {
        return this.app.style.palette[this.color_index];
      }
    });

    return Track;

  })(Point);

  define(function() {
    var Node;
    return Node = (function(superClass) {
      extend(Node, superClass);

      function Node(app, id1, arg) {
        var i, j, ref, state;
        this.id = id1;
        ref = arg != null ? arg : {}, i = ref.i, j = ref.j, this.title = ref.title, state = ref.state, this.color_index = ref.color_index, this.description = ref.description, this.conditions = ref.conditions;
        Node.__super__.constructor.call(this, app, i, j);
        this.draw();
        this.set_event_handlers(this.group);
        this.update_drawing();
        this.state = state;
        this.is_hover = false;
      }

      Node.prototype.update = function(upt) {
        var c, id, ref, u;
        if (upt.title !== void 0) {
          this.title = upt.title;
        }
        if (upt.description !== void 0) {
          this.description = upt.description;
        }
        if (upt.conditions !== void 0) {
          ref = upt.conditions;
          for (id in ref) {
            u = ref[id];
            c = this.conditions[id];
            if (u.title !== void 0) {
              c.title = u.title;
            }
            if (u.description !== void 0) {
              c.description = u.description;
            }
            if (u.state !== void 0) {
              this.set_conditions_states(id, u.state);
            }
          }
        }
        if (upt.state !== void 0) {
          return this.state = upt.state;
        }
      };

      Node.prototype.update_tracks = function() {
        var l, len, ref, results, t;
        ref = this.tracks;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          t = ref[l];
          results.push(t.update_group());
        }
        return results;
      };

      Node.prototype.set_tracks = function(tracks) {
        var t;
        return this.tracks = (function() {
          var l, len, results;
          results = [];
          for (l = 0, len = tracks.length; l < len; l++) {
            t = tracks[l];
            results.push(new Track(this.app, this, this.app.metro.grid[t.child], t.djs, t.color_index));
          }
          return results;
        }).call(this);
      };

      Node.prototype.set_conditions_states = function(id, state) {
        var comp_new, comp_old, r0, rescale;
        comp_old = this.completion;
        if (state !== this.conditions[id].state) {
          r0 = this.app.style.node.radius;
          rescale = (function(_this) {
            return function(s) {
              var m;
              m = new Snap.Matrix();
              m.scale(s, s, _this.x, _this.y);
              return _this.group.transform(m);
            };
          })(this);
          Snap.animate(1, 1.2, rescale, 200, mina.easeout);
          Snap.animate(1.2, 1, rescale, 400, mina.easeout);
        }
        this.conditions[id].state = state;
        comp_new = this.completion;
        return Snap.animate(comp_old * 359.99, comp_new * 359.99, (function(_this) {
          return function(angle) {
            return _this.completion_circle.attr({
              d: _this.create_completion_circle(_this.x, _this.y, _this.app.style.node.radius, _this.app.style.node.completion.angle_offset, angle)
            });
          };
        })(this), this.app.style.node.completion.duration, mina.easeout);
      };

      Node.prototype.draw = function() {
        var path;
        this.circle = this.app.metro.svg.circle(this.x, this.y, this.app.style.node.radius);
        this.circle.attr({
          strokeWidth: this.app.style.node.stroke_width
        });
        path = this.create_completion_circle(this.x, this.y, this.app.style.node.radius, this.app.style.node.completion.angle_offset, this.completion * 359.99);
        this.completion_circle = this.app.metro.svg.path(path);
        this.completion_circle.attr({
          opacity: this.app.style.node.completion.opacity
        });
        this.group = this.app.metro.svg.group();
        this.group.add(this.circle);
        this.group.add(this.completion_circle);
        return this.group.node.style.cursor = 'pointer';
      };

      Node.prototype.update_drawing = function() {
        var color, highlight, s;
        color = tinycolor(this.color);
        color = '#' + (this.is_hover ? color.lighten() : color).toHex();
        s = this.app.style.node.highlight;
        highlight = '';
        if (this.selected) {
          highlight = this.app.metro.svg.filter(Snap.filter.shadow(s.x, s.y, s.blur, this.color, s.opacity));
        }
        this.circle.attr({
          fill: this.app.style.node.fill,
          stroke: color,
          filter: highlight
        });
        return this.completion_circle.attr({
          fill: color
        });
      };

      Node.prototype.create_completion_circle = function(cx, cy, r, start, angle) {
        var is_large_arc, p_end, p_start, path;
        p_start = {
          x: cx + r * Math.cos(Math.PI * start / 180),
          y: cy + r * Math.sin(Math.PI * start / 180)
        };
        p_end = {
          x: cx + r * Math.cos(Math.PI * (start + angle) / 180),
          y: cy + r * Math.sin(Math.PI * (start + angle) / 180)
        };
        is_large_arc = angle > 180 ? 1 : 0;
        return path = "M" + cx + "," + cy + " L" + p_start.x + "," + p_start.y + " A" + r + "," + r + " 0 " + is_large_arc + ",1 " + p_end.x + "," + p_end.y + " L" + cx + "," + cy + " Z";
      };

      Node.property('color', {
        get: function() {
          return this.app.style.palette[this.color_index];
        }
      });

      Node.property('state', {
        get: function() {
          return this._state;
        },
        set: function(s) {
          this._state = s;
          if (this.is_active) {
            return this.app.metro.groups.active_nodes.add(this.group);
          } else {
            return this.app.metro.groups.inactive_nodes.add(this.group);
          }
        }
      });

      Node.property('is_active', {
        get: function() {
          return this.state === "active" || this.state === "done";
        }
      });

      Node.property('completion', {
        get: function() {
          var _, c, completion, done, total;
          done = (function() {
            var ref, results;
            ref = this.conditions;
            results = [];
            for (_ in ref) {
              c = ref[_];
              if (c.state === 'done') {
                results.push(c);
              }
            }
            return results;
          }).call(this);
          total = (function() {
            var ref, results;
            ref = this.conditions;
            results = [];
            for (_ in ref) {
              c = ref[_];
              results.push(c);
            }
            return results;
          }).call(this);
          return completion = done.length / total.length;
        }
      });

      Node.prototype.onhover = function(e) {
        this.is_hover = true;
        return this.update_drawing();
      };

      Node.prototype.unhover = function(e) {
        this.is_hover = false;
        return this.update_drawing();
      };

      Node.prototype.onclick = function(e) {
        return this.toggle_select();
      };

      return Node;

    })(SelectablePoint);
  });

}).call(this);
